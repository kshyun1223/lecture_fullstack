# 20220801

## 강의 내용

### 이번주 배울 내용

- 전처리기(preprocessor)

### 폭포수 모델(Waterfall Model)

1. 소프트웨어 요구사항 기술
2. 소프트웨어 설계
3. 소프트웨어 구현 (또는 코딩)
4. 시험과 디버깅
5. 설치
6. 소프트웨어 유지보수

### 컴파일

- **컴퓨터가 CSS를 만들어주고 있는 과정**
- 백엔드에서는 일상적인 단어
    - 프론트엔드에서는 못 하는 일을 가능하게 하는 결정적인 역할
- 인터프리터(interpreter) 언어
    - 자바스크립트, 파이썬
    - 별다른 변환이 없어도 진행이 가능
    - 한 줄 읽으면 한 줄 해석: 인간과 흡사하다
    - 일반적인 경우 로딩 과정을 따로 마련하지 않는다
    - 위에서부터 아래로, 왼쪽에서부터 오른쪽으로
- 컴파일(compile) 언어
    - 기본적으로 로딩을 한다. “걸린다” 라고 하지 않고 “로딩을 진행한다” 고 한다
        - load: 적재하다
        - 로딩이 오래걸린다 = 데이터를 적재하는 과정이 오래걸린다
    - 컴파일언어는 로딩을 통해서 무언가 변환한다
    - 전통적인 컴파일링이라면 기계어로 변환하는 과정
    - C, C++, C#, Java: 컴파일러가 존재

### Pre-processing

- SASS: CSS 전처리기(preprocessor)라고 부른다

### 개발 환경 구축

- SASS는 VSCODE 확장 프로그램도 있지만 터미널로도 설치할 수 있다
- 개발환경 구축은 상당히 고도의 작업: 한번에 한개씩만 조치 하고 확인

### SCSS vs. SASS

- SCSS는 문법적으로 기존 CSS와 좀더 유사하고, SASS는 파이썬과 유사하다

### SCSS 파일을 작성하면 자동으로 생기는 것들

- 필요해서 생기는 거기 때문에 지우면 귀찮아진다
    - 파일명.css.map 파일: 지도 역할
    - css 파일에도 밑에 주석으로 무언가 생김

### SCSS의 장점

- CSS 작업의 추상화(고도화)를 실현: 압도적인 생산성
    - 굳이 컴파일러를 사용하는 이유
    - SASS Compiler: 기계어가 아닌 CSS로 컴파일한다
    - 그렇기 때문에 사용법을 익혀야 한다는 단점
- 전처리 뿐만아니라 유지보수에도 탁월하다
    - 특히 디자인 같은 경우 매번 바꿀 수 있어야 한다
- 재사용성이 뛰어나다
    - 변수(variable)를 선언(declaration)할 수 있다
    - 한번 선언하고 여러번 할당: 보다 프로그래밍 언어에 가까움
- 별도의 검토 작업 없이 그냥 사용하는 것만으로 웹 표준을 준수한다
- 실무적인 측면에서 SCSS로 **마크업 작업을 빠르게 끝내고 알고리즘에 집중**할 수 있다
    - 개발자의 경우. 반면 디자이너들은 컨텐츠와 연출론에 집중하기 때문에 마크업 생산성을 추구할 필요가 없다.
- 교육적인 측면에서 마크업언어와 자바스크립트의 사이에 중간 단계를 만들 수 있다 (진입장벽을 낮춤)
    - 하지만 기능은 자바스크립트가 훨씬 강력하고, 기본기는 CSS가 더 중요하다
- 향후 전망은 전처리기가 따로 필요 없이 CSS에 기능이 포함될 것으로 보인다
    - 이미 변수 선언 가능. 중첩(nesting)도 곧 도입될 예정.
    - **미리 배워놓으면 기술을 선점할 수 있다.**

### 변수

- 다양하게 처리가 가능하다
- 마치 사람의 언변처럼 어떻게든 사용해도 된다
- “복잡도가 높아진다”: 코드가 한번에 읽히지 않는 현상
    - **작명**을 하기 때문에 생기는 어쩔 수 없는 상황

### 리터럴

- 리터럴(literal): 작성(속성과 값 모두를)을 직접 하는 행위
    - 예시: {display:flex;} -> 디스플레이 속성에 플렉스 값을 리터럴로 할당했다
    - 단점: 수정해야 될 때 개발자가 직접 다시 작성해야 한다
- 실제로는 직접 선언하여 할당하는 경우가 많기 때문에 다른 사람이 알아보기가 힘들어진다
    - “값은 모르지만 뭔지 알것만 같다”라는 감각: 프로그래밍에서 굉장히 중요한 사고방식
- 변수로 할당한 어떤 값을 “추상화되었다” 라고 표현한다 -> 한번에 이해하기가 어려운 상태

### SCSS(SASS) 작성법

https://sass-lang.com/guide

- 자식관계를 중첩(nesting)을 통해 빠르게 해결할 수 있다
    - 중괄호 사이에 다른 선택자를 사용하는 것 -> CSS에서는 불가능한 방식
- 변수를 선언할 수 있다
    - 방법: {$변수명 : 값;}
    - 클래스와 ID를 아낄 수 있다: 머리가 편해진다(생산성이 높아진다)

### 생산성을 추구할 수 있는 이유

- 하드웨어의 기능이 상향되었기 때문
    - 임베디드 같은 분야에서는 아직 저수준 언어인 C를 사용한다

### 폴더트리

- 프로젝트 폴더에 파일과 하위폴더를 구획하는 작업
    - 프론트엔드는 보통 CSS, img, js 폴더와 index.html 파일로 시작한다

### CSS 사용법

- 인라인 방식: 태그에 속성을 부여
- 내부스타일시트 방식: head > style 영역에서 일괄 관리
    - 의의: 인라인 방식으로 매번 쓰기 불편하기 때문에 사용, 유지보수의 용이성
    - 한계: 해당 파일에만 국한된다, 외부스타일시트를 사용하여 극복
- 외부스타일시트 방식: `<link rel="stylesheet" href="파일명.css">` 태그를 입력
    - 최상위 디렉토리(root directory) 개념이 등장: 흔히 새폴더, 시작폴더
    - rel(relative), href(hyper reference)
    - <a>(문서를 이동) vs. <link>(문서를 연결)
    - `<link>` 태그
        - 문서와 문서를 마치 거미줄처럼 연결
        - **경로(Path)**: 상위파일과 하위파일이라는 개념이 생긴다 (부모태그, 자식태그의 관계와 흡사하다)
    - 상대경로(관계 기준으로 탐색)
        - href 속성에 사용 가능, 리눅스 명령어와 동일
        - ./ 를 입력하면 하위 디렉토리를 탐색
        - ../ 를 입력하면 상위 디렉토리를 탐색
    - 한계: 단일파일이 아니기 때문에 구성이 복잡해진다
    - 모듈화(modify): 외부스타일시트도 일종의 모듈이라고 할 수 있다
        - 선언과 할당의 개념이 적용됨

### 코딩 잘 하는 사람의 특징

- 반복해서 쓰지 않는다
- 반복할 거리를 잘 찾는다 = 모듈

### 구조화 작업

- 어떻게 구조를 짜야 효과적인지 어려웠을 것
- 막히는 부분들 목록화
- 이렇게 해결할 수도 있구나
- 내것으로 다시 돌아오는 것
- 내가 만드는 것도 구조화를 하겠구나 라는 확신

### 중첩 위주 구조 vs. 관계 위주 구조

- 부모에서부터 자식 순으로 작업을 해버릇 하는 습관은 -> 프로그래밍 할 때 작업부담을 줄이는 매우 훌륭한 습관
- 한번에 한개만 보는 것 -> 머리가 맑아진다

### 의도적으로 관계를 사용하는 이유

- 스타일링 우선순위 때문에 가장 하위에 있는 것으로 최대한 쓰려고 하는 경향
    - 약한레벨 -> 강한레벨
    - id는 우선순위가 지나치게 높음
    - SCSS를 사용하면 단점 보완 가능
    - 파악하기도 의외로 좋다.
1. 예제(디자인 시안)
    1. structuring:설계법
2. 문서를 만드는 -> 퍼블리셔
3. 문서를 찍어내는 기계를 만드는 것 -> 개발자
    1. 구조를 모르면 알고리즘을 짤 수가 없다.
    2. 구조를 알면 알고리즘도 짠다.

### 공공데이터포털

- `data.go.kr`

## 오늘 할 일

### **CSS를 너무 안일하게 생각한듯… 집중 보충 필요.**

### 느낀점

- 프론트엔드와 백엔드라는 직무의 구분이 나타난 이유는 사람이 선천적으로 가지고 있는, 타고난 감각의 차이 때문인 것 같다. 또한 그로 인해 생산성의 차이가 나타나기 때문이기도 하다.
- 기술 자체만 놓고 보자면 같은 프로그래밍인 이상 얼마든지 타 직무의 영역을 이해할 수 있다. 그리고 스스로에게 떳떳한 개발자라면 반드시 그래야만 한다. 하지만 단순히 기술을 이해하는 것과 직접 수행해서 높은 생산성을 내는 것은 별개의 영역인 것 같다.
- 내가 전부터 생각했던 개발자의 모습은 백엔드 개발자였다. 단지 백엔드는 취업의 문이 좁다고 해서, 다들 프론트엔드부터 시작해서 경력이 쌓이면 백엔드로 전향한다고 해서 막연하게 프론트엔드를 해야겠다고 생각했었다.
- 하지만 여기까지 생각하게 된 이상, 아직도 프론트엔드를 고집한다면 나 자신과 나를 믿어줘서 일을 맡기고 월급을 주는 회사 양쪽을 모두 속이는 일이 될 것이다. 신입 백엔드 개발자의 취업문이 아무리 좁다고 해도 죽기살기로 해서 꼭 좋은 회사에 들어가보자.

### 생각해볼 점

- 안하는 것과 못하는 것은 확실하게 구분하자