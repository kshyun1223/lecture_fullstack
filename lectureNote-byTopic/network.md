# 네트워크
## 렌더링
### 렌더링(rendering)
문서를 파싱하여 브라우저에 시각적으로 출력하는 것

### 파싱(parsing)
- 언어의 문법에 맞게 작성된 텍스트 문서를 읽어들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 트리 형태의 자료구조를 생성하는 과정

### DOM(Document Object Model)
텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다. 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다.

### DOM tree
DOM tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델을 의미한다. 객체의 트리로 구조화되어 있기 때문에 DOM tree라 부른다.

### CSSOM
- 렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나아가다가 CSS를 만나면 파싱을 중단한다
- 그리고 CSS에 대해 HTML과 동일한 파싱 과정을 거쳐서 CSSOM을 생성한다
- 이후 HTML 파싱이 중단된 지점부터 다시 파싱을 재개한다

### attachment
- 파싱 과정에서 HTML을 먼저 호출한 다음에 CSS를 합치는 단계
- console.dir에서 스타일 속성을 조회해보면 빈칸이 나오는 이유는 CSS가 로드되기 이전 단계에서 조회하기 때문이다

## 노드
### 문서 노드

### 엘리먼트 노드

### 어트리뷰트 노드

### 텍스트 노드

## 그 외
### UDP
User Datagram Protocol의 축약어로 컴퓨터가 다른 컴퓨터와 데이터 통신을 하기 위한 규약(프로토콜)의 일종이다.

### 프로토콜(protocol)
컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계

### 클라이언트(Client), 호스트(Host), 서버(Server)
음식점에 비유하자면 클라이언트는 손님이고, 호스트는 점주이며, 서버는 종업원이라고 할 수 있다. 

### 정적 페이지 vs. 동적 페이지
- 정적 페이지: HTML과 CSS로만 작업한 것
- 동적 웹페이지: 프로그래밍 언어를 사용하여 작업한 것
    - SSR(서버사이드 렌더링): Next.js
    - CSR(클라이언트 사이드 렌더링): React.js

### 동기 vs. 비동기
- 작성법의 영역이 아님: 인간의 입장에서는 ‘동작을 예측’해야 한다
- 다행스럽게도 자바스크립트 엔진은 일정한 규칙에 의해서 움직인다
    - 동기(순차 우선)방식: 어떤 때는 안전을 위해 순차적으로 해야 될 때도 있다
    - 비동기(실행 우선)방식: 어떤 때는 효율을 위해 동시에 해야 할 때도 있다
        - setTimeout(), setInterval()
        - 효율을 우선시하는 방식 -> 자바스크립트의 기조
    - 순서 + 실행 + 순서 + 실행: 복합적으로 사용

### packet
- 패킷은 header와 body로 이루어져 있다. html만의 전유물이 아니었던 것이다.
- c언어는 헤더와 바디를 구분하는 대표적인 언어다(`#include stdint.h`)
- 자바스크립트는 스크립트 언어이기 때문에 헤더에 관한 부분을 감춰놓았다
- header: 근원적인 정보가 담겨있는 데이터이기 때문에 metadata라고 한다
- bundler 작업은 header를 다루는 단계라고 할 수 있다

### http
- 디버깅: 데이터를 제대로 받아왔는지 확인하는 행위
  - 콘솔에 익숙해졌기 때문에 할 수 있는 콘솔의 다음 단계
  - 중요한 건 폴더명, 파일명, 변수명 밖에 없다
  - 글로벌 변수: 빌트인인지 라이브러리인지 구분하려면 여기서 찾으면 된다

- node.js 빌트인 객체 조회: 브라우저에서 조회할 때랑 다르지 않다. 쩜이면 객체, 소괄호면 함수.
  - http도 절대적인 것이 아니다: http2가 이미 나와있다
  - 데이터타입 외에는 없다: 작성법이 아니라 기반지식이 부족한거다

```javascript
let imsi = []
for (let key in http){
  imsi.push(key)
}
console.log(imsi)

```

- 개발자도구 => 네트워크 탭 => 헤더 탭
  - 메서드, 상태코드, 응답헤더, 요청헤더 등...

- html 헤드에 있는 link 태그는 서버한테 GET 요청을 보내는 방식이다 
  - 트랜젝션
  - 백엔드는 바디보다 헤드가 더 중요하다

- 브라우저는 별다른 지시가 없어도 일단 접속하면 GET 요청을 하나 보낸다

- 결론: 요청=>request(method, url) => 원하는대로 파일을 처리할 수 있다
  - 이걸 사람이 아니라 기계가 해서 서버임
  - GET, POST, url 등등 = 규칙
  - "개발자는 문자열에 맞춰서 동작되게만 만들면 된다" => {인풋===문자열, 아웃풋===문자열, 처리!==문자열}